# coding: utf-8
# static analysis: ignore
from __future__ import print_function
from __future__ import absolute_import
from __future__ import division

"""

Tests for the test_scope.py script.

"""

import ast
from asynq import FutureBase, AsyncTask
import collections
import os
import six
import sys
import types

from qcore.asserts import assert_eq, assert_is, assert_in
from .name_check_visitor import (
    _get_task_cls,
    _static_hasattr,
    ClassAttributeChecker,
    NameCheckVisitor,
)
from .arg_spec import assert_is_value, ArgSpecCache, dump_value
from .error_code import ErrorCode
from .test_config import TestConfig
from .value import (
    AsyncTaskIncompleteValue,
    DictIncompleteValue,
    KnownValue,
    MultiValuedValue,
    NewTypeValue,
    ReferencingValue,
    SequenceIncompleteValue,
    TypedValue,
    UnboundMethodValue,
    UNINITIALIZED_VALUE,
    UNRESOLVED_VALUE,
    VariableNameValue,
    AwaitableIncompleteValue,
    SubclassValue,
    GenericValue,
    TypedDictValue,
)
from .tests import proxied_fn, autogenerated, l0cached_async_fn, PropertyObject
from . import test_node_visitor
from .test_node_visitor import assert_passes, assert_fails, only_before, skip_before


# ===================================================
# Base classes for test_scope tests.
#
# These are also used in scope_lib files.
# ===================================================


class ConfiguredNameCheckVisitor(NameCheckVisitor):
    """NameCheckVisitor configured for testing.

    Should be called TestNameCheckVisitor but that would cause it to be confused with test classes.

    """

    config = TestConfig()


class TestNameCheckVisitorBase(test_node_visitor.BaseNodeVisitorTester):
    visitor_cls = ConfiguredNameCheckVisitor

    def _run_tree(
        self,
        code_str,
        tree,
        check_attributes=True,
        apply_changes=False,
        settings=None,
        **kwargs
    ):
        # This can happen in Python 2.
        if isinstance(code_str, bytes):
            code_str = code_str.decode("utf-8")
        default_settings = {code: True for code in ErrorCode}
        if settings is not None:
            default_settings.update(settings)
        verbosity = int(os.environ.get("ANS_TEST_SCOPE_VERBOSITY", 0))
        mod = _make_module(code_str)
        with ClassAttributeChecker(
            self.visitor_cls.config, enabled=check_attributes
        ) as attribute_checker:
            return self.visitor_cls(
                mod.__name__,
                code_str,
                tree,
                module=mod,
                attribute_checker=attribute_checker,
                settings=default_settings,
                verbosity=verbosity,
                arg_spec_cache=ArgSpecCache(self.visitor_cls.config),
                **kwargs
            ).check_for_test(apply_changes=apply_changes)


class TestAnnotatingNodeVisitor(test_node_visitor.BaseNodeVisitorTester):
    """Base class for testing AnnotatingNodeVisitor subclasses."""

    def _run_tree(self, code_str, tree, **kwargs):
        """Runs the visitor on this tree."""
        kwargs["module"] = _make_module(code_str)
        return super(TestAnnotatingNodeVisitor, self)._run_tree(
            code_str, tree, **kwargs
        )


def _make_module(code_str):
    """Creates a Python module with the given code."""
    module_name = "<test input>"
    if six.PY2:
        module_name = module_name.encode("ascii")
    mod = types.ModuleType(module_name)
    scope = mod.__dict__
    # make helpers for value inference checking available to all tests
    scope.update(
        assert_is_value=assert_is_value,
        AsyncTaskIncompleteValue=AsyncTaskIncompleteValue,
        DictIncompleteValue=DictIncompleteValue,
        GenericValue=GenericValue,
        KnownValue=KnownValue,
        MultiValuedValue=MultiValuedValue,
        SequenceIncompleteValue=SequenceIncompleteValue,
        TypedValue=TypedValue,
        UnboundMethodValue=UnboundMethodValue,
        UNRESOLVED_VALUE=UNRESOLVED_VALUE,
        VariableNameValue=VariableNameValue,
        AwaitableIncompleteValue=AwaitableIncompleteValue,
        ReferencingValue=ReferencingValue,
        SubclassValue=SubclassValue,
        NewTypeValue=NewTypeValue,
        TypedDictValue=TypedDictValue,
        dump_value=dump_value,
        UNINITIALIZED_VALUE=UNINITIALIZED_VALUE,
        __name__=module_name,
    )
    exec (code_str, scope)
    sys.modules[module_name] = mod
    return mod


# ===================================================
# Tests for specific functionality.
# ===================================================


def test_annotation():
    args = (ast.Name("int", ast.Load()), [], [])
    if sys.version_info < (3, 5):
        args = args + (None, None)
    tree = ast.Call(*args)
    ConfiguredNameCheckVisitor(
        "<test input>", u"int()", tree, module=ast, annotate=True
    ).check()
    assert_eq(TypedValue(int), tree.inferred_value)


class TestNameCheckVisitor(TestNameCheckVisitorBase):
    @assert_fails(ErrorCode.undefined_name)
    def test_undefined_name(self):
        def run():
            print(undefined_variable)

    @assert_fails(ErrorCode.undefined_attribute)
    def test_undefined_attribute(self):
        def run():
            lst = []
            print(lst.coruro)

    def test_undefined_name_with_star_import(self):
        # can't use the decorator version because import * isn't allowed with nested functions
        self.assert_fails(
            ErrorCode.undefined_name,
            """
from qcore.asserts import *
def run():
    print(not_in_qcore.asserts)
""",
        )

    @assert_fails(ErrorCode.undefined_name)
    def test_undefined_name_in_return(self):
        def what_is_it():
            return tucotuco

    @assert_passes()
    def test_no_failure_on_builtin(self):
        def run():
            print(len)

    @assert_passes()
    def test_no_failure_on_global(self):
        capybara = 3

        def run():
            print(capybara)

    @assert_passes()
    def test_no_failure_on_global_return(self):
        tucotuco = "a burrowing rodent"

        def what_is_it():
            return tucotuco

    @assert_passes()
    def test_no_failure_on_arg(self):
        def double_it(x):
            return x * 2

    @assert_passes()
    def test_class_scope(self):
        class Porcupine(object):
            def coendou(self):
                return 1

            sphiggurus = coendou

    @assert_fails(ErrorCode.undefined_name)
    def test_class_scope_fails_wrong_order(self):
        def run():
            class Porcupine(object):
                sphiggurus = coendou

                def coendou(self):
                    return 1

    @assert_fails(ErrorCode.undefined_name)
    def test_class_scope_is_not_searched(self):
        class Porcupine(object):
            sphiggurus = 1

            def coendou(self):
                return sphiggurus

    @assert_passes()
    def test_getter_decorator(self):
        class Porcupine(object):
            sphiggurus = property()

            @sphiggurus.getter
            def sphiggurus(self):
                pass

    @assert_passes()
    def test_none_global_whitelisting(self):
        a = None

        def run():
            print(a.pweb.ip())

    @assert_passes()
    def test_ipython_whitelisting(self):
        def run():
            print(__IPYTHON__)

    @assert_passes()
    def test_mock_attributes(self):
        def cavy():
            pass

        def run():
            print(cavy.call_count)

    @assert_passes()
    def test_mock_attr(self):
        try:
            from unittest import mock
        except ImportError:
            import mock

        class X:
            a = mock.MagicMock()

        class Y:
            def __init__(self):
                self.x = X()

        def f():
            y = Y()
            assert_is_value(y.x.a, KnownValue(X.a))

    @assert_passes()
    def test_method_mock_attributes(self):
        class Capybara(object):
            def hutia(self):
                pass

            def kerodon(self):
                print(self.hutia.call_count)

    @assert_passes()
    def test_global_assignment(self):
        from qcore.asserts import assert_eq

        fn = assert_eq

        def run():
            assert_is_value(fn, KnownValue(assert_eq))

    @assert_fails(ErrorCode.undefined_attribute)
    def test_builtin_attribute(self):
        def run():
            print(True.hutia)

    @assert_passes()
    def test_module_reassignment(self):
        _std_set = set

        def set(key, value):
            return _std_set([key, value])

        _std_set()

    @assert_fails(ErrorCode.not_callable)
    def test_display(self):
        def run():
            print([1, 2]())

    @assert_fails(ErrorCode.unhashable_key)
    def test_list_in_set(self):
        def run():
            print({[]})

    @assert_passes()
    def test_multiple_assignment_global(self):
        if False:
            goes_in_set = []
        else:
            goes_in_set = "capybara"
        if False:
            assert_is_value(
                goes_in_set, MultiValuedValue([KnownValue("capybara"), KnownValue([])])
            )
            print({goes_in_set})

    @assert_passes()
    def test_multiple_assignment_function(self):
        def fn(cond):
            if cond:
                goes_in_set = []
            else:
                goes_in_set = "capybara"
            assert_is_value(
                goes_in_set, MultiValuedValue([KnownValue("capybara"), KnownValue([])])
            )
            print({goes_in_set})

    @assert_fails(ErrorCode.duplicate_dict_key)
    def test_duplicate_dict_key(self):
        def run():
            print({"capybara": 1, "capybara": 2})

    @assert_fails(ErrorCode.unhashable_key)
    def test_unhashable_dict_key(self):
        def run():
            print({[]: 1})

    @assert_fails(ErrorCode.duplicate_dict_key)
    def test_inferred_duplicate_dict_key(self):
        key = "capybara"

        def run():
            print({"capybara": 1, key: 1})

    @assert_fails(ErrorCode.unhashable_key)
    def test_inferred_unhashable_dict_key(self):
        key = []

        def run():
            print({key: 1})

    @assert_fails(ErrorCode.bad_unpack)
    def test_too_many_values_to_unpack(self):
        def run():
            a, b = 1, 2, 3
            return a, b

    @assert_fails(ErrorCode.bad_unpack)
    def test_too_few_values_to_unpack(self):
        def run():
            a, b, c = 1, 2
            return a, b, c

    @assert_fails(ErrorCode.bad_unpack)
    def test_too_many_values_to_unpack_list(self):
        def run():
            [a, b, c] = 1, 2
            return a, b, c

    @assert_passes()
    def test_correct_unpack(self):
        def run():
            a, b = 1, 2
            return a, b

    @assert_fails(ErrorCode.not_callable)
    def test_unpack_int(self):
        def run():
            a, b = 1, 2
            a()
            return a, b

    @assert_passes()
    def test_unpack_inference(self):
        def run(s):
            a, b = 1, int(s)
            assert_is_value(a, KnownValue(1))
            assert_is_value(b, TypedValue(int))

    @assert_fails(ErrorCode.undefined_name)
    def test_nested_classes(self):
        class Caviids(object):
            class Capybaras(object):
                if False:
                    print(neochoerus)

    @assert_fails(ErrorCode.undefined_name)
    def test_class_in_function(self):
        def get_capybaras(object):
            class Capybaras(object):
                if False:
                    print(neochoerus)

    @assert_fails(ErrorCode.unsupported_operation)
    def test_cant_del_tuple(self):
        tpl = (1, 2, 3)

        def run():
            del tpl[1]

    @assert_fails(ErrorCode.unsupported_operation)
    def test_cant_del_generator(self):
        tpl = (x for x in (1, 2, 3))

        def run():
            del tpl[1]

    @assert_fails(ErrorCode.unsupported_operation)
    def test_cant_assign_tuple(self):
        tpl = (1, 2, 3)

        def run():
            tpl[1] = 1

    @assert_passes()
    def test_binop(self):
        def tucotuco():
            assert_is_value(2 + 3, KnownValue(5))

    @assert_passes()
    def test_global_sets_value(self):
        capybara = None

        def set_it():
            global capybara
            capybara = [0]

        def use_it():
            print(capybara[0])

    @assert_fails(ErrorCode.unsupported_operation)
    def test_self_type_inference(self):
        class Capybara(object):
            def get(self, i):
                assert_is_value(self, TypedValue(Capybara))
                return self[i]

    @assert_passes()
    def test_self_is_subscriptable(self):
        class Capybara(object):
            def get(self, i):
                return self[i]

            def __getitem__(self, i):
                return i

    @assert_passes()
    def test_cls_type_inference(self):
        class OldStyle:
            def __init_subclass__(cls):
                assert_is_value(cls, SubclassValue(OldStyle))

            def __new__(cls):
                assert_is_value(cls, SubclassValue(OldStyle))

    @assert_passes()
    def test_cls_type_inference(self):
        class OldStyle:
            @classmethod
            def capybara(cls):
                pass

    @assert_passes()
    def test_display_type_inference(self):
        def capybara(a, b):
            x = [a, b]
            assert_is_value(
                x, SequenceIncompleteValue(list, [UNRESOLVED_VALUE, UNRESOLVED_VALUE])
            )
            y = a, 2
            assert_is_value(
                y, SequenceIncompleteValue(tuple, [UNRESOLVED_VALUE, KnownValue(2)])
            )
            s = {a, b}
            assert_is_value(
                s, SequenceIncompleteValue(set, [UNRESOLVED_VALUE, UNRESOLVED_VALUE])
            )
            z = {a: b}
            assert_is_value(
                z, DictIncompleteValue([(UNRESOLVED_VALUE, UNRESOLVED_VALUE)])
            )
            q = {a: 3, b: 4}
            assert_is_value(
                q,
                DictIncompleteValue(
                    [
                        (UNRESOLVED_VALUE, KnownValue(3)),
                        (UNRESOLVED_VALUE, KnownValue(4)),
                    ]
                ),
            )

    @assert_passes()
    def test_if_exp(self):
        def capybara(x):
            y = 3 if x else 4
            assert_is_value(y, MultiValuedValue([KnownValue(3), KnownValue(4)]))

    @assert_fails(ErrorCode.undefined_attribute)
    def test_namedtuple(self):
        import collections

        typ = collections.namedtuple("typ", "foo bar")

        def fn():
            t = typ(1, 2)
            print(t.baz)

    @assert_passes()
    def test_set_after_get(self):
        def fn():
            capybara = None
            for _ in range(5):
                if capybara:
                    print(capybara[0])
                capybara = "foo"

    @assert_passes()
    def test_multiple_UNRESOLVED_VALUEs(self):
        def fn(item):
            if False:
                item = None
            print(item["id"])

    @assert_fails(ErrorCode.undefined_attribute)
    def test_bad_attribute_of_global(self):
        import os

        path = os.path

        def capybara():
            print(path.joyn)

    @assert_passes()
    def test_double_assignment(self):
        from pyanalyze.tests import PropertyObject

        def capybara(aid):
            answer = PropertyObject(aid)
            print(answer)
            answer = PropertyObject(aid)
            assert_is_value(answer, TypedValue(PropertyObject))

    @assert_fails(ErrorCode.class_variable_redefinition)
    def test_duplicate_method(self):
        class Tucotuco(object):
            def __init__(self, fn):
                pass

            def __init__(self, an):
                pass

    @assert_fails(ErrorCode.class_variable_redefinition)
    def test_duplicate_attribute(self):
        import enum

        class Hutia:
            capromys = 1
            capromys = 2

    @assert_passes()
    def test_duplicate_attribute_augassign(self):
        class Capybara:
            x = 1
            x += 1

    @assert_passes()
    def test_duplicate_property_method(self):
        class Capybara(object):
            @property
            def fur(self):
                return "a lot"

            @fur.setter
            def fur(self, value):
                pass

    @assert_fails(ErrorCode.bad_global)
    def test_bad_global(self):
        global x

    @assert_fails(ErrorCode.undefined_name)
    def test_undefined_global(self):
        def fn():
            global x
            return x

    @assert_passes()
    def test_global_value(self):
        x = 3

        def capybara():
            global x
            assert_is_value(x, KnownValue(3))

    @assert_fails(ErrorCode.condition_always_true)
    def test_assert_never_fails(self):
        def capybara():
            assert "this doesn't work"

    @assert_passes()
    def test_assert_bad_bool(self):
        class X(object):
            def __bool__(self):
                raise Exception("I am a poorly behaved object")

            __nonzero__ = __bool__

        x = X()

        def capybara():
            assert x

    @skip_before((3, 0))
    def test_no_return(self):
        self.assert_passes(
            """
from typing_extensions import NoReturn
from typing import Optional

def f() -> NoReturn:
    raise Exception

def capybara(x: Optional[int]) -> None:
    if x is None:
        f()
    assert_is_value(x, TypedValue(int))
"""
        )


class TestSubclassValue(TestNameCheckVisitorBase):
    @skip_before((3, 5))
    # In 3.7 the behavior of Type[] changed.
    @only_before((3, 7))
    def test_annotations_in_arguments(self):
        self.assert_passes(
            """
from typing import Type

TI = Type[int]

def capybara(x: TI, y: str):
    assert_is_value(x, SubclassValue(int))
    assert_is_value(y, TypedValue(str))
"""
        )

    @skip_before((3, 5))
    @only_before((3, 7))
    def test_type_any(self):
        self.assert_passes(
            """
from typing import Any, Type

def f(x) -> Type[Any]:
    return type(x)

def capybara():
    f(1)
    assert_is_value(f(1), TypedValue(type))
"""
        )

    @assert_passes()
    def test_call_method_through_type(self):
        class A:
            def run(self):
                pass

            @classmethod
            def call_on_instance(cls, instance):
                assert_is_value(cls.run, KnownValue(A.run))
                cls.run(instance)


class TestAttributes(TestNameCheckVisitorBase):
    @only_before((3, 0))
    @assert_passes()
    def test_name_special_casing(self):
        def capybara():
            assert_is_value(
                KnownValue.__name__,
                MultiValuedValue(
                    [KnownValue(b"KnownValue"), KnownValue(u"KnownValue")]
                ),
            )

    @assert_passes()
    def test_attrs(self):
        import attr

        @attr.s(frozen=True)
        class Capybara(object):
            value = attr.ib()
            int_value = attr.ib(type=int)

        def kerodon():
            c = Capybara(42, 43)
            assert_is_value(c.value, UNRESOLVED_VALUE)
            assert_is_value(c.int_value, TypedValue(int))

    @skip_before((3, 6))
    def test_attribute_in_annotations(self):
        self.assert_passes(
            """
class Capybara:
    capybara_id: int
    kerodon_id: object = None

def capybara():
    assert_is_value(Capybara.kerodon_id, TypedValue(object))
    c = Capybara()
    return c.capybara_id
"""
        )

    @skip_before((3, 6))
    def test_attribute_in_base_class(self):
        self.assert_passes(
            """
from typing import Optional

union = MultiValuedValue([KnownValue(None), TypedValue(int)])

class Capybara:
    capybara_id: Optional[int] = None

    @classmethod
    def clsmthd(cls):
        assert_is_value(cls.capybara_id, union)

class DefiniteCapybara(Capybara):
    capybara_id = 3

    @classmethod
    def clsmthd(cls):
        assert_is_value(cls.capybara_id, KnownValue(3))

def capybara():
    assert_is_value(Capybara().capybara_id, union)
    assert_is_value(Capybara.capybara_id, union)
    assert_is_value(DefiniteCapybara().capybara_id, KnownValue(3))
    assert_is_value(DefiniteCapybara.capybara_id, KnownValue(3))
"""
        )

    @skip_before((3, 6))
    def test_attribute_union(self):
        self.assert_passes(
            """
class A:
    x: int

class B:
    x: str

class C(B):
    y: float

def capybara() -> None:
    assert_is_value(A().x, TypedValue(int))
    assert_is_value(C().y, TypedValue(float))
    assert_is_value(C().x, TypedValue(str))
"""
        )

    @skip_before((3, 0))
    @assert_passes()
    def test_name_py3(self):
        def capybara():
            assert_is_value(KnownValue.__name__, KnownValue(u"KnownValue"))

    @assert_passes()
    def test_attribute_type_inference(self):
        from pyanalyze.tests import PropertyObject

        class Capybara(object):
            def init(self, aid):
                self.answer = PropertyObject(aid)

            def tree(self):
                assert_is_value(self.answer, TypedValue(PropertyObject))
                return []

    @assert_passes()
    def test_property_on_unhashable_object(self):
        class CustomDescriptor(object):
            __hash__ = None

            def __get__(self, obj, typ):
                if obj is None:
                    return self
                return 3

        class Unhashable(object):
            __hash__ = None

            prop = CustomDescriptor()

        def use_it():
            assert_is_value(Unhashable().prop, UNRESOLVED_VALUE)

    @assert_passes()
    def test_tuple_subclass_with_getattr(self):

        # Inspired by pyspark.sql.types.Row
        class Row(tuple):
            def __getattr__(self, attr):
                return attr.upper()

        def capybara():
            x = Row()
            return x.capybaras


class TestConditionAlwaysTrue(TestNameCheckVisitorBase):
    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_if_expr(self):
        True if object() else False

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_method(self):
        class Capybara(object):
            def eat(self):
                pass

            def maybe_eat(self):
                if self.eat:
                    self.eat()

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_typed_value(self):
        class Capybara(object):
            pass

        if Capybara():
            pass

    @assert_passes()
    def test_overrides_len(self):
        class Capybara(object):
            def __len__(self):
                return 42

        if Capybara():
            pass

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_and(self):
        object() and False

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_and_chain(self):
        [] and object() and False

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_or(self):
        object() or True

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_not(self):
        not object()

    @assert_fails(ErrorCode.non_boolean_in_boolean_context)
    def test_async_yield_or(self):
        from asynq import asynq

        @asynq()
        def kerodon():
            return 42

        @asynq()
        def capybara():
            yield kerodon.asynq() or 0


class TestReturnTypeInference(TestNameCheckVisitorBase):
    @assert_passes()
    def test(self):
        from asynq import asynq, async_proxy, AsyncTask, ConstFuture, FutureBase

        def returns_3():
            return 3

        @asynq(pure=True)
        def pure_async_fn():
            return 4

        @asynq()
        def async_fn():
            return 3

        class WithAProperty(object):
            @property
            def this_is_one(self):
                return str(5)

        @async_proxy(pure=True)
        def pure_async_proxy(oid):
            return ConstFuture(oid)

        @async_proxy()
        def impure_async_proxy():
            return ConstFuture(3)

        def capybara(oid):
            assert_is_value(returns_3(), KnownValue(3))
            assert_is_value(
                pure_async_fn(), AsyncTaskIncompleteValue(AsyncTask, KnownValue(4))
            )
            assert_is_value(async_fn(), KnownValue(3))
            assert_is_value(
                async_fn.asynq(), AsyncTaskIncompleteValue(AsyncTask, KnownValue(3))
            )
            assert_is_value(WithAProperty().this_is_one, TypedValue(str))
            assert_is_value(pure_async_proxy(oid), TypedValue(ConstFuture))
            assert_is_value(impure_async_proxy(), UNRESOLVED_VALUE)
            assert_is_value(
                impure_async_proxy.asynq(),
                AsyncTaskIncompleteValue(FutureBase, UNRESOLVED_VALUE),
            )


class TestUnwrapYield(TestNameCheckVisitorBase):
    @assert_passes()
    def test(self):
        from asynq import asynq

        @asynq()
        def async_fn(n):
            return "async_fn"

        @asynq()
        def square(n):
            return int(n * n)

        class Capybara(object):
            @asynq()
            def async_method(self):
                return "capybara"

        @asynq()
        def caller():
            val1 = yield async_fn.asynq(1)
            assert_is_value(val1, KnownValue("async_fn"))
            val2 = yield square.asynq(3)
            assert_is_value(val2, TypedValue(int))

            val3, val4 = yield async_fn.asynq(1), async_fn.asynq(2)
            assert_is_value(val3, KnownValue("async_fn"))
            assert_is_value(val4, KnownValue("async_fn"))

            val5 = yield Capybara().async_method.asynq()
            assert_is_value(val5, KnownValue("capybara"))

            vals1 = yield [square.asynq(1), square.asynq(2), square.asynq(3)]
            assert_is_value(
                vals1,
                SequenceIncompleteValue(
                    list, [TypedValue(int), TypedValue(int), TypedValue(int)]
                ),
            )

            vals2 = yield [square.asynq(i) for i in [0, 1, 2]]
            for val in vals2:
                assert_is_value(val, TypedValue(int))

            vals3 = yield {1: square.asynq(1)}
            assert_is_value(
                vals3, DictIncompleteValue([(KnownValue(1), TypedValue(int))])
            )

            vals4 = yield {i: square.asynq(i) for i in [0, 1, 2]}
            assert_is_value(
                vals4,
                GenericValue(
                    dict,
                    [
                        MultiValuedValue([KnownValue(0), KnownValue(1), KnownValue(2)]),
                        TypedValue(int),
                    ],
                ),
            )


class TestYieldFrom(TestNameCheckVisitorBase):
    @skip_before((3, 2))
    def test(self):
        self.assert_passes(
            """
from typing import Iterator

def f(x) -> Iterator[int]:
    yield from x
"""
        )
        self.assert_passes(
            """
def capybara(x):
    yield from [1, 2]
"""
        )
        self.assert_fails(
            ErrorCode.bad_yield_from,
            """
def capybara():
    yield from 3
""",
        )


class TestClassAttributeChecker(TestNameCheckVisitorBase):
    @assert_passes()
    def test_mangled_attributes(self):
        class Capybara(object):
            def __mangled(self):
                pass

            def other_method(self):
                self.__mangled()

    @assert_fails(ErrorCode.attribute_is_never_set)
    def test_never_set(self):
        class Capybara(object):
            def method(self):
                return self.doesnt_exist

    @assert_passes()
    def test_exists_on_class(self):
        class Capybara(object):
            @classmethod
            def type(cls):
                pass

            def method(self):
                return self.__class__.type()

    @assert_fails(ErrorCode.attribute_is_never_set)
    def test_in_classmethod(self):
        class Capybara(object):
            @classmethod
            def do_stuff(cls):
                return cls.stuff

    @assert_passes()
    def test_getattribute_overridden(self):
        class GetAttribute(object):
            def __getattribute__(self, attr):
                return 42

            def foo(self):
                return self.answer

    @assert_passes()
    def test_base_attribute(self):
        class Capybara(object):
            def __init__(self, obj):
                self.obj = str(obj)

        class Neochoerus(Capybara):
            def eat(self):
                assert_is_value(self.obj, TypedValue(str))

    @assert_passes()
    def test_unexamined_base(self):
        from pyanalyze.tests import PropertyObject

        # this base class was not examined, so we don't know if it has the attribute
        class Capybara(PropertyObject):
            def tree(self):
                return self.this_attribute_does_not_exist

    @assert_fails(ErrorCode.attribute_is_never_set)
    def test_cythonized_unexamined_base(self):
        import qcore

        # this base class was also not examined, but it is Cython so we can still know that the
        # attribute does not exist
        class Capybara(qcore.decorators.DecoratorBase):
            def tree(self):
                return self.this_attribute_does_not_exist

    @assert_passes()
    def test_setattr(self):
        class Capybara(object):
            def __init__(self):
                for k, v in iter([("grass", "tasty")]):
                    assert_is_value(k, UNRESOLVED_VALUE)
                    setattr(self, k, v)
                assert_is_value(self.grass, UNRESOLVED_VALUE)

    @assert_passes()
    def test_setattr_on_base(self):
        class Capybara(object):
            def __init__(self):
                for k, v in iter([("grass", "tasty")]):
                    # Make sure we're not smart enough to infer the attribute
                    assert_is_value(k, UNRESOLVED_VALUE)
                    setattr(self, k, v)
                assert_is_value(self.grass, UNRESOLVED_VALUE)

        class Neochoerus(Capybara):
            def eat(self):
                # this doesn't exist, but we shouldn't alert because there is a setattr() on the
                # base
                self.consume(self.grass)


class TestBadRaise(TestNameCheckVisitorBase):
    @assert_fails(ErrorCode.bad_exception)
    def test_bad_value(self):
        def tainotherium():
            raise NotImplemented

    @assert_fails(ErrorCode.bad_exception)
    def test_bad_type(self):
        def tainotherium():
            # make sure this isn't inferenced to KnownValue, so this tests what it's supposed to
            # test
            assert_is_value(int("3"), TypedValue(int))
            raise int("3")

    @assert_fails(ErrorCode.bad_exception)
    def test_wrong_type(self):
        def tainotherium():
            raise bool

    @assert_passes()
    def test_raise_type(self):
        def tainotherium():
            raise NotImplementedError

    @assert_passes()
    def test_reraise(self):
        def tainotherium():
            try:
                pass
            except OSError:
                raise

    @assert_passes()
    def test_raise_value(self):
        def tainotherium():
            raise ValueError("not valuable")


class TestVariableNameValue(TestNameCheckVisitorBase):
    @assert_passes()
    def test(self):
        def name_ends_with_uid(uid):
            return uid

        def test(self):
            assert_is_value(name_ends_with_uid, KnownValue(name_ends_with_uid))
            uid = 3
            assert_is_value(uid, VariableNameValue(["uid"]))
            another_uid = "hello"
            assert_is_value(another_uid, KnownValue("hello"))

            d = {"uid": self}
            assert_is_value(d["uid"], VariableNameValue(["uid"]))
            assert_is_value(self.uid, VariableNameValue(["uid"]))


class TestFunctionsSafeToCall(TestNameCheckVisitorBase):
    @assert_passes()
    def test(self):
        def test(self):
            assert_is_value(sorted([3, 1, 2]), KnownValue([1, 2, 3]))


class TestImports(TestNameCheckVisitorBase):
    def test_star_import(self):
        self.assert_passes(
            """
from qcore.asserts import *

assert_eq(1, 1)
"""
        )

    @assert_passes()
    def test_local_import(self):
        import qcore as _qcore

        def capybara(foo):
            import qcore

            assert_is_value(qcore.utime, KnownValue(_qcore.utime))

    @assert_passes()
    def test_local_import_from(self):
        from qcore.asserts import assert_eq as _assert_eq

        def capybara(foo):
            from qcore.asserts import assert_eq

            assert_is_value(assert_eq, KnownValue(_assert_eq))


class TestNameOfKnownValue(TestNameCheckVisitorBase):
    @assert_passes()
    def test_varname(self):
        from pyanalyze.tests import PropertyObject

        def capybara(proper_capybara):
            assert_is_value(proper_capybara, TypedValue(PropertyObject))

        def hutia(arg):
            proper_capybara = 1
            assert_is_value(proper_capybara, KnownValue(1))

    @assert_passes()
    def test_attribute(self):
        from pyanalyze.tests import PropertyObject

        class Capybara(object):
            def __init__(self, foo, bar):
                self.proper_capybara = foo

            def eat(self):
                assert_is_value(self.proper_capybara, TypedValue(PropertyObject))

        class Hutia(object):
            def __init__(self, arg):
                self.proper_capybara = int(arg)

            def eat(self):
                assert_is_value(self.proper_capybara, TypedValue(int))


class TestComprehensions(TestNameCheckVisitorBase):
    @only_before((3, 0))
    @assert_passes()
    def test_scoping_in_list_py2(self):
        def capybara(self):
            x = [a for a in (1, 2)]
            return a, x

    @skip_before((3, 0))
    @assert_fails(ErrorCode.undefined_name)
    def test_scoping_in_list_py3(self):
        def capybara(self):
            x = [a for a in (1, 2)]
            return a, x

    @assert_fails(ErrorCode.undefined_name)
    def test_scoping_in_set(self):
        def capybara(self):
            x = {a for a in (1, 2)}
            return a, x

    @assert_fails(ErrorCode.undefined_name)
    def test_scoping_in_generator(self):
        def capybara(self):
            x = (a for a in (1, 2))
            return a, x

    @assert_fails(ErrorCode.undefined_name)
    def test_scoping_in_dict(self):
        def capybara(self):
            x = {a: 3 for a in (1, 2)}
            return a, x

    @assert_passes()
    def test_incomplete_value(self):
        import types

        def capybara(lst):
            a = [int(x) for x in lst]
            assert_is_value(a, GenericValue(list, [TypedValue(int)]))

            b = (0 for _ in lst)
            assert_is_value(b, GenericValue(types.GeneratorType, [KnownValue(0)]))

            c = {int(x): int(x) for x in lst}
            assert_is_value(c, GenericValue(dict, [TypedValue(int), TypedValue(int)]))

    @assert_passes()
    def test_sequence_iterable(self):
        # this failed previously because str has no __iter__, but is iterable
        def capybara(oid):
            tmp = str(oid)
            return [s for s in tmp]

    @assert_fails(ErrorCode.undefined_name)
    def test_comprehension_body_within_class(self):
        def capybara():
            class Capybara(object):
                incisors = [1, 2]
                canines = {incisors[0] for _ in incisors}

    @skip_before((3, 0))
    @assert_passes()
    def test_comprehension_within_class(self):
        class Capybara(object):
            incisors = [1, 2]
            canines = {i + 1 for i in incisors}


class TestIterationTarget(TestNameCheckVisitorBase):
    @assert_passes()
    def test_known(self):
        def capybara():
            for char in "hello":
                assert_is_value(
                    char,
                    MultiValuedValue(
                        [
                            KnownValue("h"),
                            KnownValue("e"),
                            KnownValue("l"),
                            KnownValue("o"),
                        ]
                    ),
                )

            for num in [1, 2, 3]:
                assert_is_value(
                    num, MultiValuedValue([KnownValue(1), KnownValue(2), KnownValue(3)])
                )

            for elt in [1, None, "hello"]:
                assert_is_value(
                    elt,
                    MultiValuedValue(
                        [KnownValue(1), KnownValue(None), KnownValue("hello")]
                    ),
                )

    @assert_fails(ErrorCode.unsupported_operation)
    def test_known_not_iterable(self):
        def capybara():
            for _ in 3:
                pass

    @assert_fails(ErrorCode.unsupported_operation)
    def test_typed_not_iterable(self):
        def capybara(x):
            for _ in int(x):
                pass

    @skip_before((3, 5))
    def test_union_iterable(self):
        self.assert_passes(
            """
from typing import List, Set, Union

def capybara(x: Union[List[int], Set[str]]) -> None:
    for obj in x:
        assert_is_value(obj, MultiValuedValue([TypedValue(int), TypedValue(str)]))
"""
        )

    @assert_passes()
    def test_incomplete(self):
        def capybara(x):
            lst = [1, 2, int(x)]
            assert_is_value(
                lst,
                SequenceIncompleteValue(
                    list, [KnownValue(1), KnownValue(2), TypedValue(int)]
                ),
            )
            for elt in lst:
                assert_is_value(
                    elt,
                    MultiValuedValue([KnownValue(1), KnownValue(2), TypedValue(int)]),
                )

    @assert_passes()
    def test_list_comprehension(self):
        def capybara():
            lst = [x for x in (1, 2)]
            mvv = MultiValuedValue([KnownValue(1), KnownValue(2)])
            assert_is_value(lst, GenericValue(list, [mvv]))
            for y in lst:
                assert_is_value(y, mvv)

    @assert_passes()
    def test_dict_comprehension(self):
        def capybara():
            dct = {x: x for x in (1, 2, 3)}
            mvv = MultiValuedValue([KnownValue(1), KnownValue(2), KnownValue(3)])
            assert_is_value(dct, GenericValue(dict, [mvv, mvv]))

            for key in dct:
                assert_is_value(key, mvv)


class TestAddImports(TestNameCheckVisitorBase):
    def test_top_level(self):
        self.assert_is_changed(
            """
import sys

def capybara():
    return qcore.utime()
""",
            """
import qcore
import sys

def capybara():
    return qcore.utime()
""",
        )

    def test_from(self):
        self.assert_is_changed(
            """
from qcore.asserts import assert_eq

def capybara():
    assert_is(3, 4)
""",
            """
from qcore.asserts import assert_eq, assert_is

def capybara():
    assert_is(3, 4)
""",
        )

        self.assert_is_changed(
            """
import sys

def capybara():
    assert_is(3, 4)
""",
            """
from qcore.asserts import assert_is
import sys

def capybara():
    assert_is(3, 4)
""",
        )


class TestNestedFunction(TestNameCheckVisitorBase):
    @assert_passes()
    def test_inference(self):
        def capybara():
            def nested():
                pass

            class NestedClass(object):
                pass

            assert_is_value(nested, KnownValue(nested))
            assert_is_value(NestedClass, TypedValue(type))

    @assert_passes()
    def test_usage_in_nested_scope():
        def capybara(cond, x):
            if cond:

                def nested(y):
                    pass

                ys = [nested(y) for y in x]

                class Nested(object):
                    xs = ys

    @assert_fails(ErrorCode.incompatible_call)
    def test_argument_mismatch(self):
        def capybara():
            def nested():
                pass

            nested(None)

    @assert_passes()
    def test_async(self):
        from asynq import asynq, result

        @asynq()
        def capybara():
            @asynq()
            def nested():
                return 3

            assert_is_value(nested, KnownValue(nested))
            result((yield nested.asynq()))

    @assert_passes()
    def test_bad_decorator(self):
        import types

        def decorator(fn):
            return fn

        def capybara():
            @decorator
            def nested():
                pass

            assert_is_value(nested, TypedValue(types.FunctionType))

    @assert_passes()
    def test_attribute_set(self):
        def capybara():
            def inner():
                pass

            inner.punare = 3
            print(inner.punare)


class TestYieldInComprehension(TestNameCheckVisitorBase):
    # this became a syntax error in 3.8
    @only_before((3, 8))
    def test_list(self):
        self.assert_fails(
            ErrorCode.yield_in_comprehension,
            """
def capybara():
    [(yield x) for x in []]
""",
        )

    @only_before((3, 8))
    def test_set(self):
        self.assert_fails(
            ErrorCode.yield_in_comprehension,
            """
def capybara():
    {(yield x) for x in []}
""",
        )

    @only_before((3, 8))
    def test_dict(self):
        self.assert_fails(
            ErrorCode.yield_in_comprehension,
            """
def capybara():
    {(yield x): (yield y) for x in []}
""",
        )

    @only_before((3, 8))
    def test_yield_in_condition(self):
        self.assert_fails(
            ErrorCode.yield_in_comprehension,
            """
def capybara():
    [x for x in [] if (yield x)]
""",
        )

    @assert_passes()
    def test_body_only(self):
        def capybara(y):
            [x for x in (yield y)]


class TestUnboundMethodValue(TestNameCheckVisitorBase):
    @assert_passes()
    def test_inference(self):
        from pyanalyze.tests import PropertyObject, ClassWithAsync

        def capybara(oid):
            assert_is_value(
                PropertyObject(oid).non_async_method,
                UnboundMethodValue("non_async_method", PropertyObject),
            )
            assert_is_value(
                PropertyObject(oid).async_method,
                UnboundMethodValue("async_method", PropertyObject),
            )
            assert_is_value(
                ClassWithAsync().get_async,
                UnboundMethodValue("get_async", ClassWithAsync),
            )
            assert_is_value(
                ClassWithAsync().get, UnboundMethodValue("get", ClassWithAsync)
            )
            assert_is_value([oid].append, UnboundMethodValue("append", list))

    @assert_passes()
    def test_metaclass_super(self):
        class Metaclass(type):
            def __init__(self, name, bases, attrs):
                super(Metaclass, self).__init__(name, bases, attrs)
                # TODO(jelle): the value is inferred correctly but this test fails because identical super
                # objects don't compare equal
                # assert_is_value(super(Metaclass, self).__init__,
                #                 UnboundMethodValue('__init__', super(Metaclass, Metaclass)))
                assert_is_value(
                    self.__init__, UnboundMethodValue("__init__", Metaclass)
                )


class TestSubscripting(TestNameCheckVisitorBase):
    @assert_passes()
    def test_list_success(self):
        def capybara():
            return [1, 2][0]

    @assert_passes()
    def test_tuple_success(self):
        def capybara():
            return (1, 2)[0]

    @assert_passes()
    def test_str_success(self):
        def capybara():
            return "12"[0]

    @assert_passes()
    def test_custom_index(self):
        class CustomIndex(object):
            def __index__(self):
                return 0

        def capybara():
            return [1, 2][CustomIndex()]

    @assert_passes()
    def test_slice(self):
        def capybara():
            return [1, 2][1:]

    @assert_fails(ErrorCode.unsupported_operation)
    def test_failure(self):
        def capybara():
            return [1, 2][3.0]


class TestPython3Compatibility(TestNameCheckVisitorBase):
    @only_before((3, 0))
    def test_floordiv(self):
        self.assert_is_changed(
            """
4 / 3
""",
            """
4 // 3
""",
        )

    @only_before((3, 0))
    def test_floordiv_long(self):
        self.assert_is_changed(
            """
4L / 3
""",
            """
4L // 3
""",
        )

    def test_floordiv_with_future_import(self):
        self.assert_passes(
            """
from __future__ import division
4 / 3
"""
        )

    @assert_fails(ErrorCode.mixing_bytes_and_text)
    def test_bytes_and_text(self):
        def capybara():
            return b"foo" + u"bar"

    @assert_fails(ErrorCode.mixing_bytes_and_text)
    def test_text_and_bytes(self):
        def capybara():
            return u"foo" + b"bar"


class TestOperators(TestNameCheckVisitorBase):
    @assert_passes()
    def test_not(self):
        def capybara(x):
            assert_is_value(not x, TypedValue(bool))
            assert_is_value(not True, TypedValue(bool))

    @assert_passes()
    def test_unary_op(self):
        def capybara(x):
            assert_is_value(~x, UNRESOLVED_VALUE)
            assert_is_value(~3, KnownValue(-4))

    @skip_before((3, 6))  # relies on typeshed
    @assert_passes()
    def test_binop_type_inference(self):
        import six

        def capybara(x):
            assert_is_value(1 + int(x), TypedValue(int))
            assert_is_value(3 * int(x), TypedValue(int))
            assert_is_value(u"foo" + six.text_type(x), TypedValue(six.text_type))
            assert_is_value(1 + float(x), TypedValue(float))
            assert_is_value(1.0 + int(x), TypedValue(float))

    @assert_fails(ErrorCode.unsupported_operation)
    def test_unsupported_unary_op(self):
        def capybara():
            ~"capybara"


class TestTaskNeedsYield(TestNameCheckVisitorBase):
    @assert_fails(ErrorCode.task_needs_yield)
    def test_constfuture(self):
        from asynq import asynq, ConstFuture

        @asynq()
        def bad_async_fn():
            return ConstFuture(3)

    @assert_fails(ErrorCode.task_needs_yield)
    def test_async(self):
        from asynq import asynq, ConstFuture

        @asynq()
        def async_fn():
            pass

        @asynq()
        def bad_async_fn():
            return async_fn.asynq()

    @assert_fails(ErrorCode.task_needs_yield)
    def test_not_yielded(self):
        from asynq import asynq
        from pyanalyze.tests import async_fn

        @asynq()
        def capybara(oid):
            return async_fn.asynq(oid)

    def test_not_yielded_replacement(self):
        self.assert_is_changed(
            """
from asynq import asynq
from pyanalyze.tests import async_fn

@asynq()
def capybara(oid):
    async_fn.asynq(oid)
""",
            """
from asynq import asynq
from pyanalyze.tests import async_fn

@asynq()
def capybara(oid):
    yield async_fn.asynq(oid)
""",
        )


class TestAsyncAwait(TestNameCheckVisitorBase):
    @skip_before((3, 5))
    def test_type_inference(self):
        self.assert_passes(
            """
async def capybara(x):
    assert_is_value(x, UNRESOLVED_VALUE)
    return 'hydrochoerus'

async def kerodon(x):
    task = capybara(x)
    assert_is_value(task, AwaitableIncompleteValue(KnownValue('hydrochoerus')))
    val = await task
    assert_is_value(val, KnownValue('hydrochoerus'))
"""
        )

    @skip_before((3, 5))
    def test_type_error(self):
        self.assert_fails(
            ErrorCode.unsupported_operation,
            """
async def capybara():
    await None
""",
        )

    @skip_before((3, 6))
    def test_async_comprehension(self):
        self.assert_passes(
            """
class ANext:
    def __anext__(self) -> int:
        return 42

class AIter:
    def __aiter__(self) -> ANext:
        return ANext()

async def f():
    x = [y async for y in AIter()]
    assert_is_value(x, GenericValue(list, [TypedValue(int)]))
"""
        )

    @skip_before((3, 6))
    def test_bad_async_comprehension(self):
        self.assert_fails(
            ErrorCode.unsupported_operation,
            """
async def f():
    return [x async for x in []]
""",
        )


class TestKeywordOnlyArguments(TestNameCheckVisitorBase):
    @skip_before((3, 0))
    def test_success(self):
        self.assert_passes(
            """
def capybara(a, *, b, c=3):
    assert_is_value(a, UNRESOLVED_VALUE)
    assert_is_value(b, UNRESOLVED_VALUE)
    assert_is_value(c, MultiValuedValue([UNRESOLVED_VALUE, KnownValue(3)]))
    capybara(1, b=2)

    fn = lambda a, *, b: assert_is_value(b, UNRESOLVED_VALUE)
    fn(a, b=b)
"""
        )

    @skip_before((3, 0))
    def test_failure(self):
        self.assert_fails(
            ErrorCode.incompatible_call,
            """
def capybara(a, *, b):
    capybara(1, 2)
""",
        )


class TestExplicitPrefixForNonAscii(TestNameCheckVisitorBase):
    @assert_passes()
    def test_negatives(self):
        "foo"
        b"foo"
        b"f\xff0"
        u"féo"

    @only_before((3, 0))
    def test_non_ascii_bytes(self):
        self.assert_fails(ErrorCode.implicit_non_ascii_string, u'"féo"')
        self.assert_fails(ErrorCode.implicit_non_ascii_string, u'"f\xffo"')


class TestMissingAwait(TestNameCheckVisitorBase):
    @skip_before((3, 4))
    def test_asyncio_coroutine_internal(self):
        self.assert_fails(
            ErrorCode.missing_await,
            """
import asyncio

@asyncio.coroutine
def f():
    yield from asyncio.sleep(3)

@asyncio.coroutine
def g():
    f()
""",
        )
        self.assert_passes(
            """
import asyncio

@asyncio.coroutine
def f():
    yield from asyncio.sleep(3)

@asyncio.coroutine
def g():
    yield from f()
"""
        )

    @skip_before((3, 4))
    def test_asyncio_coroutine_external(self):
        self.assert_fails(
            ErrorCode.missing_await,
            """
import asyncio

@asyncio.coroutine
def f():
    asyncio.sleep(3)
""",
        )
        self.assert_is_changed(
            """
import asyncio

@asyncio.coroutine
def f():
    asyncio.sleep(3)
""",
            """
import asyncio

@asyncio.coroutine
def f():
    yield from asyncio.sleep(3)
""",
        )
        self.assert_passes(
            """
import asyncio

@asyncio.coroutine
def f():
    yield from asyncio.sleep(3)
"""
        )

    @skip_before((3, 5))
    def test_async_def_internal(self):
        self.assert_fails(
            ErrorCode.missing_await,
            """
async def f():
    return 42

async def g():
    f()
""",
        )
        self.assert_passes(
            """
async def f():
    return 42

async def g():
    await f()
"""
        )

    @skip_before((3, 5))
    def test_async_def_external(self):
        self.assert_fails(
            ErrorCode.missing_await,
            """
import asyncio

async def f():
    asyncio.sleep(1)
""",
        )
        self.assert_is_changed(
            """
import asyncio

async def f():
    asyncio.sleep(1)
""",
            """
import asyncio

async def f():
    await asyncio.sleep(1)
""",
        )
        self.assert_passes(
            """
import asyncio

async def f():
    await asyncio.sleep(1)
"""
        )


class TestNonlocal(TestNameCheckVisitorBase):
    @skip_before((3, 0))
    def test_nonlocal(self):
        self.assert_passes(
            """
from qcore.testing import Anything

def capybara():
    x = 3

    def inner_capybara():
        nonlocal x
        assert_is_value(x, MultiValuedValue([
            KnownValue(4),
            KnownValue(3),
            KnownValue(5),
        ]))
        x = 4
        assert_is_value(x, KnownValue(4))

    def second_inner():
        nonlocal x
        # this should not throw unused_variable
        x = 5

    return x
"""
        )

    @skip_before((3, 0))
    def test_no_unused_var(self):
        self.assert_passes(
            """
def loop():
    running = True

    def handler():
        nonlocal running
        running = False

    return running
"""
        )


class TestingCallSiteCollector(object):
    """Records as string instead of actual reference so can be tested.

    Replaces name_check_visitor.py:CallSiteCollector, since that class records
    real references, which are hard to test against.

    """

    def __init__(self):
        self.map = collections.defaultdict(list)

    def record_call(self, caller, callee):
        try:
            self.map[callee.__qualname__].append(caller.__qualname__)
        except TypeError:
            # Copied for consistency; see comment in name_check_visitor.py:CallSiteCollector
            pass


class TestCallSiteCollection(TestNameCheckVisitorBase):
    """Base class for testing call site collection."""

    def run_and_get_call_map(self, code_str, **kwargs):
        collector = TestingCallSiteCollector()
        self._run_str(code_str, collector=collector, **kwargs)
        return collector.map

    # __qualname__ added in 3.3
    @skip_before((3, 3))
    def test_member_function_call(self):
        call_map = self.run_and_get_call_map(
            """
class TestClass(object):
    def __init__(self):
        self.first_function(5)

    def first_function(self, x):
        print(x)
        self.second_function(x, 4)

    def second_function(self, y, z):
        print(y + z)
"""
        )

        assert_in("TestClass.first_function", call_map["TestClass.second_function"])
        assert_in("TestClass.__init__", call_map["TestClass.first_function"])
        assert_in("TestClass.second_function", call_map["print"])

    # __qualname__ added in 3.3
    @skip_before((3, 3))
    def test_nested_function_call(self):
        call_map = self.run_and_get_call_map(
            """
class TestClass(object):
    def __init__(self):
        def second_function(y):
            print(y)
        second_function(3)
"""
        )

        assert_in("TestClass.__init__", call_map["second_function"])
        assert_in("second_function", call_map["print"])


def test_get_task_cls():
    assert_is(FutureBase, _get_task_cls(proxied_fn))
    assert_is(AsyncTask, _get_task_cls(autogenerated))
    assert_is(AsyncTask, _get_task_cls(l0cached_async_fn))
    assert_is(AsyncTask, _get_task_cls(PropertyObject(1).l0cached_async_method))


class TestBadAsyncYield(TestNameCheckVisitorBase):
    @assert_passes()
    def test_const_future(self):
        from asynq import asynq, ConstFuture, FutureBase

        @asynq()
        def capybara(condition):
            yield FutureBase()
            val = yield ConstFuture(3)
            assert_is_value(val, KnownValue(3))
            val2 = yield None
            assert_is_value(val2, KnownValue(None))

            if condition:
                task = ConstFuture(4)
            else:
                task = capybara.asynq(True)
            val3 = yield task
            assert_is_value(val3, MultiValuedValue([KnownValue(4), UNRESOLVED_VALUE]))


class TestAugAssign(TestNameCheckVisitorBase):
    @assert_passes()
    def test_aug_assign(self):
        def capybara(condition):
            x = 1
            x += 2
            assert_is_value(x, KnownValue(3))


class TestUnpackingGeneralizations(TestNameCheckVisitorBase):
    @skip_before((3, 5))
    def test_dict_unpacking(self):
        self.assert_passes(
            """
def capybara():
    d1 = {1: 2}
    d2 = {3: 4, **d1}
    assert_is_value(d2, TypedValue(dict))
"""
        )

    @skip_before((3, 5))
    def test_tuple_unpacking(self):
        self.assert_passes(
            """
def capybara(x):
    degu = (1, *x)
    assert_is_value(degu, TypedValue(tuple))
"""
        )


class TestUnusedIgnore(TestNameCheckVisitorBase):
    @assert_fails(ErrorCode.unused_ignore)
    def test_unused(self):
        def capybara(condition):
            x = 1
            print(x)  # static analysis: ignore

    @assert_passes()
    def test_used(self):
        def capybara(condition):
            print(x)  # static analysis: ignore[undefined_name]


class TestMissingF(TestNameCheckVisitorBase):
    @skip_before((3, 6))
    @assert_passes()
    def test_no_error(self):
        def capybara(func):
            "x"
            "not valid syntax {}"
            b"no byte {f} {string}"
            "{undefined_name} in this string"
            x = 3
            print("a{x}".format(x=x))
            func("translate {x}", x=x)

    @skip_before((3, 6))
    @assert_fails(ErrorCode.missing_f)
    def test_missing_f(self):
        def capybara():
            x = 3
            return "x = {x}"

    @skip_before((3, 6))
    def test_autofix(self):
        self.assert_is_changed(
            """
def capybara():
    x = 3
    return "x = {x}"
""",
            """
def capybara():
    x = 3
    return f'x = {x}'
""",
        )


class TestFStrings(TestNameCheckVisitorBase):
    @skip_before((3, 6))
    def test_fstr(self):
        self.assert_passes(
            """
def capybara(x):
    y = f"{x} stuff"
    assert_is_value(y, TypedValue(str))
"""
        )
        self.assert_fails(
            ErrorCode.undefined_name,
            """
def capybara():
    return f"{x}"
""",
        )


class TestTypedDict(TestNameCheckVisitorBase):
    @skip_before((3, 0))
    def test_basic(self):
        self.assert_passes(
            """
from mypy_extensions import TypedDict as METypedDict
from typing_extensions import TypedDict as TETypedDict

T = METypedDict("T", {"a": int, "b": str})
T2 = TETypedDict("T2", {"a": int, "b": str})

def capybara(x: T, y: T2):
    assert_is_value(x, TypedDictValue({"a": TypedValue(int), "b": TypedValue(str)}))
    assert_is_value(x["a"], TypedValue(int))
    assert_is_value(y, TypedDictValue({"a": TypedValue(int), "b": TypedValue(str)}))
    assert_is_value(y["a"], TypedValue(int))
"""
        )
        self.assert_passes(
            """
from mypy_extensions import TypedDict

T = TypedDict("T", {"a": int, "b": str})

def capybara(x: T):
    assert_is_value(x["not a key"], UNRESOLVED_VALUE)
"""
        )
        self.assert_fails(
            ErrorCode.invalid_typeddict_key,
            """
from mypy_extensions import TypedDict

T = TypedDict("T", {"a": int, "b": str})

def capybara(x: T):
    x[0]
""",
        )


class TestSequenceIndex(TestNameCheckVisitorBase):
    @assert_passes()
    def test_list_index(self):
        def capybara(x):
            lst = ["a", "b", int(x)]
            assert_is_value(lst[0], KnownValue("a"))
            assert_is_value(lst[2], TypedValue(int))
            assert_is_value(lst[-2], KnownValue("b"))
            assert_is_value(lst[5], UNRESOLVED_VALUE)

    @assert_passes()
    def test_tuple_index(self):
        def capybara(x):
            tpl = ["a", "b", int(x)]
            assert_is_value(tpl[0], KnownValue("a"))
            assert_is_value(tpl[2], TypedValue(int))
            assert_is_value(tpl[-2], KnownValue("b"))
            assert_is_value(tpl[5], UNRESOLVED_VALUE)

    @skip_before((3, 5))
    def test_tuple_annotation(self):
        self.assert_passes(
            """
from typing import Tuple

def capybara(tpl: Tuple[int, str, float]) -> None:
    assert_is_value(tpl[0], TypedValue(int))
    assert_is_value(tpl[-2], TypedValue(str))
    assert_is_value(tpl[2], TypedValue(float))
"""
        )


class HasGetattr(object):
    def __getattr__(self, attr):
        return 42

    def real_method(self):
        pass


class HasGetattribute(object):
    def __getattribute__(self, attr):
        return 43

    def real_method(self):
        pass


def test_static_hasattr():
    hga = HasGetattr()
    assert _static_hasattr(hga, "real_method")
    assert _static_hasattr(hga, "__getattr__")
    assert not _static_hasattr(hga, "random_attribute")

    hgat = HasGetattribute()
    assert _static_hasattr(hgat, "real_method")
    assert _static_hasattr(hgat, "__getattribute__")
    assert not _static_hasattr(hgat, "random_attribute")
